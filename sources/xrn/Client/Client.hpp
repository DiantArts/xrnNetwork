#pragma once

#include <xrn/Network/AClient.hpp>

namespace xrn::network {

///////////////////////////////////////////////////////////////////////////
/// \brief Interface detailing basic clients' features
/// \ingroup network
///
/// \include Client.hpp <xrn/Network/Client/Client.hpp>
///
/// ::xrn::network::Client's purpuse is simplify data share by providing a
/// simple way to regroup and act onto multiple data into a single object.
/// The client is designed as Event programming and the user must implement
/// the on... methods to interact with it
///
/// \see ::xrn::network::IClient, ::xrn::network::Message
///
///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::hasValueLast UserEnum
> class Client
    : public ::xrn::network::AClient<UserEnum>
{

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Client();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    /// Clears the registry opon destruction.
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual ~Client();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Client(
        const Client& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Client& other
    ) noexcept
        -> Client& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Client(
        Client&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Client&& that
    ) noexcept
        -> Client&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Events
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Event triggered when a connection with a client is established
    ///
    /// Event called just before after a connection with another client is
    /// successfully established, secured and ready to be used
    ///
    /// \param target Client with who the connection has been established
    ///
    /// \return False to prevent the message to be sent, True otherwise
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] virtual auto onConnect(
        ::std::shared_ptr<::xrn::network::Connection<UserEnum>> target
    ) -> bool override;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Event triggered when disconnected from a client
    ///
    /// Event called just before after the client is disconnected. This
    /// event is called, whether the connection has been cut or it has been
    /// lost for any other reason
    ///
    /// \param target Client with who the connection has been stopped
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual void onDisconnect(
        ::std::shared_ptr<::xrn::network::Connection<UserEnum>> target
    ) override;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Event triggered when a message is about to be sent
    ///
    /// Event called just before a message is sent to a client. This event can
    /// prevent the message to be sent or modify its content
    ///
    /// \param target Client targeted by the message
    /// \param message Mutable message sent to the target
    ///
    /// \return False to prevent the message to be sent, True otherwise
    ///
    /// \see ::xrn::network::Message
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] virtual auto onSend(
        ::std::shared_ptr<::xrn::network::Connection<UserEnum>> target
        , ::xrn::network::Message<UserEnum>& message
    ) -> bool override;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Event triggered when a message is received
    ///
    /// Event called just after receiving a message from a client.
    ///
    /// \param target Client that sent the message
    /// \param message Mutable message sent by the target
    ///
    /// \see ::xrn::network::Message
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual void onReceive(
        ::std::shared_ptr<::xrn::network::Connection<UserEnum>> target
        , ::xrn::network::Message<UserEnum>& message
    ) override;



private:

    ::std::shared_ptr<::xrn::network::Connection<UserEnum>> m_connection;

};

} // namespace xrn::network

///////////////////////////////////////////////////////////////////////////
// Implementation Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Client.impl.hpp>
