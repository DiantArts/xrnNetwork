#pragma once

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Detail/Constraint.hpp>
#include <xrn/Network/Detail/Queue.hpp>
#include <xrn/Network/Message.hpp>

namespace xrn::network {

////////////////////////////////////////////////////////////
/// \brief A UDP Connection using boost asio
///
/// \include Connection.hpp <xrn/Network/Connection.hpp>
///
/// Its purpuse is to simplifie communications between two UDP endpoints
/// It uses ::xrn::network::Message to communicate
///
/// \see ::network::Message
///
////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> class Connection
    : public ::std::enable_shared_from_this<::xrn::network::Connection<UserEnum>>
{

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Construct a new udp connection for a client
    ///
    /// Starts an asynchronous connection to a server on the asio thread
    /// disconnect() will be automatically called if needed
    ///
    /// \param socket The udp socket from asio, generated beforehand
    ///
    ////////////////////////////////////////////////////////////
    Connection(
        ::asio::io_context& asioContext
        , const ::std::string& host
        , ::std::uint16_t port
    );

    ////////////////////////////////////////////////////////////
    /// \brief Construct a new udp connection for a server
    ///
    /// Starts an asynchronous connection to a server on the asio thread
    /// disconnect() will be automatically called if needed
    ///
    /// \param socket The udp socket from asio, generated beforehand
    ///
    ////////////////////////////////////////////////////////////
    Connection(
        ::asio::ip::udp::socket socket
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    /// Calls disconnect before deleting all the resources attached
    /// to the Connection
    ///
    ////////////////////////////////////////////////////////////
    ~Connection();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline Connection(
        const Connection& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto operator=(
        const Connection& other
    ) noexcept
        -> Connection& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline Connection(
        Connection&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto operator=(
        Connection&& that
    ) noexcept
        -> Connection&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // async (asio thread) - connection
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief set a target for the UDP messages
    ///
    ////////////////////////////////////////////////////////////
    void target(
          const ::std::string& host
        , const ::std::uint16_t port
    );

    ////////////////////////////////////////////////////////////
    /// \brief Close the connection from the target
    ///
    /// Cancels every asynchronous actions and close the socket
    ///
    ////////////////////////////////////////////////////////////
    void disconect();

    ////////////////////////////////////////////////////////////
    /// \brief Test the connection's status
    ///
    /// The connection can be unusable due to disconnect calls, errors
    /// happening on other threads or the target disconnecting
    ///
    /// \return True if the connection is still usable, false otherwise
    ///
    ////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isOpen() const
        -> bool;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // async (asio thread) - outgoing messages
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Send a message
    ///
    /// Asynchronously pushes the to the message into the queue of outgoing
    /// messages
    /// If the queue was empty before the push, it then calls
    /// sendAwaitingMessages()
    ///
    /// \param message Rvalue reference to the message to send
    ///
    ////////////////////////////////////////////////////////////
    void send(
        const ::xrn::network::Message<UserEnum>& message
    );

    ////////////////////////////////////////////////////////////
    /// \brief Send a message
    ///
    /// Asynchronously pushes the to the message into the queue of outgoing
    /// messages
    /// If the queue was empty before the push, it then calls
    /// sendAwaitingMessages()
    ///
    /// \param message Rvalue reference to the message to send
    ///
    ////////////////////////////////////////////////////////////
    void send(
        ::xrn::network::Message<UserEnum>&& message
    );

    ////////////////////////////////////////////////////////////
    /// \brief Test whether there is Awaiting messages to be sent
    ///
    /// Test if the outgoing queue of messages is empty. If it is,
    /// it means no messages are awaiting to be sent
    ///
    /// \return True if messages are awaiting to be sent
    ///
    ////////////////////////////////////////////////////////////
    auto hasSendingMessagesAwaiting() const
        -> bool;

    ////////////////////////////////////////////////////////////
    /// \brief Send awaiting messages
    ///
    /// Asynchronously sends all the messages inside the outgoing queue of
    /// messages by calling sendMessage()
    /// The function recursivly clears the outgoing queue of messages
    ///
    /// \warning This method assumes at least one message waits to be sent
    /// Calling this methods without any message waiting leads to
    /// undefined behavior and/or potential segfaults
    ///
    ////////////////////////////////////////////////////////////
    void sendAwaitingMessages();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // async (asio thread) - incomming messages
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Start receiving messages
    ///
    /// Waits for incomming messages. On receive, the buffer of incomming
    /// messages is filled with the incomming message, it calls
    /// transferBufferToInQueue()
    ///
    ////////////////////////////////////////////////////////////
    void startReceivingMessage();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // helpers
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Get the port
    ///
    /// The port is choosen by the user when creating the Connection
    ///
    /// \returns Port used by the socket
    ///
    ////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getPort() const
        -> ::std::uint16_t;

    ////////////////////////////////////////////////////////////
    /// \brief Get the address
    ///
    /// The adderss is choosen by the user when creating the Connection
    ///
    /// \returns Address used by the socket
    ///
    ////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getAddress() const
        -> ::std::string;

    ////////////////////////////////////////////////////////////
    /// \brief Get the asio context
    ///
    /// \returns I/O context that has been passed at constructor
    ///
    ////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getAsioContext()
        -> ::asio::io_context&;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // async (asio thread) - outgoing messages
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Send a message in the queue
    ///
    // Same as sendMessage(), but does not copy the message, but
    // sends the message in front of the queue
    // Once sent, the message is deleted
    //
    // \param successCallback Function, lambda or class called on success
    //
    ////////////////////////////////////////////////////////////
    void sendMessage(
        auto successCallback
    );

    ////////////////////////////////////////////////////////////
    /// \brief Send the header of a message in the queue
    ///
    // Once sent, if the body is not empty, it is automatically sent as well
    //
    // \param bytesAlreadySent Allows for sending over multiple packet
    //                         already sent with previous calls
    // \param successCallback Function, lambda or class called on success
    //
    ////////////////////////////////////////////////////////////
    void sendMessageHeader(
          auto successCallback
        , ::std::size_t bytesAlreadySent = 0
    );

    ////////////////////////////////////////////////////////////
    /// \brief Send the body of a message in the queue
    ///
    /// The header of this message must has already been sent
    ///
    // \param bytesAlreadySent Allows for sending over multiple packet
    //                         already sent with previous calls
    // \param successCallback Function, lambda or class called on success
    //
    ////////////////////////////////////////////////////////////
    void sendMessageBody(
          auto successCallback
        , ::std::size_t bytesAlreadySent = 0
    );




    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // async (asio thread) - incomming messages
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Receive a message
    ///
    // Asynchronously wait on the asio thread for a messages to arrive
    // once a message arrived, it's tranfered to the incomming buffer
    // and the successCallback is called
    // In case of errors, Both Udp and Tcp connection are closed
    //
    // \param successCallback Function, lambda or class called on success
    ///
    ////////////////////////////////////////////////////////////
    void receiveMessage(
        auto successCallback
    );

    ////////////////////////////////////////////////////////////
    /// \brief Receive the header of a message in the queue
    ///
    // Once sent, if the body is not empty, it is automatically received as well
    //
    // \param bytesAlreadySent Allows to receive message over multiple packet
    // \param successCallback Function, lambda or class called on success
    //
    ////////////////////////////////////////////////////////////
    void receiveMessageHeader(
          auto successCallback
        , ::std::size_t bytesAlreadyReceived = 0
    );

    ////////////////////////////////////////////////////////////
    /// \brief Send the body of a message in the queue
    ///
    /// The header of this message must has already been received
    ///
    // \param bytesAlreadyReceived Allows to receive message over multiple packet
    // \param successCallback Function, lambda or class called on success
    //
    ////////////////////////////////////////////////////////////
    void receiveMessageBody(
          auto successCallback
        , ::std::size_t bytesAlreadyReceived = 0
    );

    ////////////////////////////////////////////////////////////
    /// \brief Push incomming mesages to the incomming queue messages
    ///
    // Convert the ::xrn::network::Message to ::xrn::network::OwnedMessage and
    // and assign the OwnedMessage's remote as this
    // Once the ::xrn::network::OwnedMessage is created, it is just pushed to the
    // queue of incomming messages that can later be pulled by the Owner
    ///
    ////////////////////////////////////////////////////////////
    void transferBufferToInQueue();



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Members
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Asio socket representing the socket
    ///
    ////////////////////////////////////////////////////////////
    ::asio::ip::udp::socket m_socket;

    ////////////////////////////////////////////////////////////
    /// \brief Buffer allowing messages to be received
    ///
    /// This message will be copied to a queue of incomming messages with
    /// transferBufferToInQueue()
    ///
    ////////////////////////////////////////////////////////////
    ::xrn::network::Message<UserEnum> m_bufferIn;

    ////////////////////////////////////////////////////////////
    /// \brief Queue of all the messages about to be sent
    ///
    ////////////////////////////////////////////////////////////
    ::xrn::network::detail::Queue<::xrn::network::Message<UserEnum>> m_messagesOut;

    ////////////////////////////////////////////////////////////
    /// \brief Create a unique identificating number for every connection
    ///
    ////////////////////////////////////////////////////////////
    static inline ::xrn::Id m_IdGenerator{ 0 };
    ::xrn::Id m_id{ ++m_IdGenerator };


    ////////////////////////////////////////////////////////////
    /// \brief If false, no messages will be sent
    ///
    ////////////////////////////////////////////////////////////
    ::std::atomic_bool m_isSendAllowed{ false };

};

} // namespace xrn::network

///////////////////////////////////////////////////////////////////////////
// Implementation Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Connection.impl.hpp>
