#pragma once

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Detail/Constraint.hpp>


namespace xrn::network {

///////////////////////////////////////////////////////////////////////////
/// \brief Allows simple Time manipulations
/// \ingroup network
///
/// \include Time.hpp <xrn/Util/Time.hpp>
///
/// ::xrn::network::Message's purpuse is simplify data share by providing a
/// simple way to regroup and act onto multiple data into a single object.
/// This message works like a queue (FIFO)
///
/// Usage example:
/// \code
/// \endcode
///
///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::hasValueLast T
> class Message {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // static elements
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type describing the message
    ///
    /// The value can be either a Message::UserType or a Message::SystemType
    /// value.
    ///
    ///////////////////////////////////////////////////////////////////////////
    using Type = ::std::uint16_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type describing a size send over
    ///
    ///////////////////////////////////////////////////////////////////////////
    using SizeType = ::std::uint16_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Alias to the enum passed as template param of the class
    ///
    ///////////////////////////////////////////////////////////////////////////
    using UserType = T;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default enum for operations outside of the user usage
    ///
    /// Constructs a ::xrn::network::Message containing a point in time with no
    /// value.
    ///
    ///////////////////////////////////////////////////////////////////////////
    enum class SystemType : ::std::uint16_t {
        builtinError = static_cast<::std::uint16_t>(Message::UserType::last) + 1,
        builtinUndefined,
        builtinNewConnection,
        builtinPing,
        builtinMessage,
        builtinMessageAll,
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Describes the contect of the message
    ///
    /// contains a value of one of both enums and a size.
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Header {
        ::std::uint16_t messageType;
        size_t bodySize{ 0 };
    } __attribute__((packed));




public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a system message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::SystemType messageType
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a user message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::UserType messageType
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a system message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::SystemType messageType,
        auto&&... args
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a user message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::UserType messageType,
        auto&&... args
    ) noexcept;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    /// Clears the registry opon destruction.
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline ~Message();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline Message(
        const Message& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto operator=(
        const Message& other
    ) noexcept
        -> Message& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline Message(
        Message&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto operator=(
        Message&& that
    ) noexcept
        -> Message&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Push
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push data into the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void push(
        auto&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push a contiguous container into the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void push(
        ::xrn::meta::constraint::isContiguousContainer auto&&... args
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Pull
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief pull a specific data from the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename DataType
    > [[ nodiscard ]] auto pull()
        -> ::std::remove_cvref_t<DataType>&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief pull a specific data from the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        ::xrn::meta::constraint::isPointer DataType
    > requires (
        !::xrn::meta::constraint::sameAs<DataType, char>
    ) [[ nodiscard ]] auto pull()
        -> ::std::span<::std::remove_cvref_t<::std::remove_pointer_t<DataType>>>;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief pull a specific data from the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        ::xrn::meta::constraint::isMemoryStr DataType
    > [[ nodiscard ]] auto pull()
        -> ::std::string;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // get
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getHeader() const
        -> const Message::Header&;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getBody() const
        -> const ::std::vector<::std::byte>&;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers size
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the size a parameter would take to allocate
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getSize(
        auto&& arg
    ) -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the size a parameter would take to allocate
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getSize(
        const char* arg
    ) -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the size that a container would take to allocate
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getSize(
        ::xrn::meta::constraint::isContiguousContainer auto&& arg
    ) -> ::std::size_t;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers push
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the data into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushMemory(
        ::std::size_t index,
        auto&& arg,
        auto&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
        ::std::size_t index,
        auto& arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
        ::std::size_t index,
        auto&& arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
        ::std::size_t index,
        const char* arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
        ::std::size_t index,
        char* arg
    );

    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
        ::std::size_t index,
        ::xrn::meta::constraint::isContiguousContainer auto& arg
    );

    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
        ::std::size_t index,
        ::xrn::meta::constraint::isContiguousContainer auto&& arg
    );



private:

    Message::Header m_header;
    ::std::vector<::std::byte> m_body; // begining of the allocated space
    ::std::size_t m_index; // current ptr for the user pulls

};

} // namespace xrn::network

///////////////////////////////////////////////////////////////////////////
// Implementation Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Message.impl.hpp>
