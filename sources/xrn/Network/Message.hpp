#pragma once

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Detail/Constraint.hpp>


namespace xrn::network {

///////////////////////////////////////////////////////////////////////////
/// \brief Allows to dynamically store polymorphic data so it can be sent
/// \ingroup network
///
/// \include Message.hpp <xrn/Network/Message.hpp>
///
/// ::xrn::network::Message's purpuse is simplify data sharing by providing
/// a simple way to regroup and act onto multiple polymorphic data into a
/// single object. This message works like a queue (FIFO)
///
/// Usage example:
/// \code
/// enum MessageType { start, stop, last };
/// ::xrn::network::Message<MessageType> m{ MessageType::start, "hello", "you"s, "are"sv };
/// ::std::vector<short> vec{ 5, 3 };
/// m.push(::std::move(vec));
/// auto str1{ m.pull<char*>() };
/// auto str2{ m.pull<char*>() };
/// auto str3{ m.pull<char*>() };
/// auto v1{ m.pull<short*>() };
/// ::fmt::print("{} {} {} {} {} {}\n", str1, str2, str3, v1.size(), v1[0], v1[1]); // output: hello you are 2 5 3
/// \endcode
///
///
///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum T
> class Message {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // static elements
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type describing the message
    ///
    /// The value can be either a Message::UserType or a Message::SystemType
    /// value.
    ///
    ///////////////////////////////////////////////////////////////////////////
    using Type = ::std::uint16_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type describing a size send over
    ///
    ///////////////////////////////////////////////////////////////////////////
    using SizeType = ::std::uint16_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Alias to the enum passed as template param of the class
    ///
    ///////////////////////////////////////////////////////////////////////////
    using UserType = T;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default enum for operations outside of the user usage
    ///
    /// Constructs a ::xrn::network::Message containing a point in time with no
    /// value.
    ///
    ///////////////////////////////////////////////////////////////////////////
    enum class SystemType : ::std::uint16_t {
        builtinError = static_cast<::std::uint16_t>(Message::UserType::last) + 1
        , builtinUndefined
        , builtinNewConnection
        , builtinPing
        , builtinMessage
        , builtinMessageAll
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Describes the contect of the message
    ///
    /// contains a value of one of both enums and a size.
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Header {
        ::std::uint16_t messageType;
        size_t bodySize{ 0 };
    } __attribute__((packed));




public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Empty message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message() noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a system message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::SystemType messageType
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a user message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::UserType messageType
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a system message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
          Message::SystemType messageType
        , auto&&... args
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a user message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
          Message::UserType messageType
        , auto&&... args
    ) noexcept;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    /// Clears the registry opon destruction.
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Message();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Message(
        const Message& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Message& other
    ) noexcept
        -> Message& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Message(
        Message&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Message&& that
    ) noexcept
        -> Message&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Push
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push data into the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void push(
        auto&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push a contiguous container into the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void push(
        ::xrn::meta::constraint::isContiguousContainer auto&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push multiple data into the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushAll(
        auto&&... args
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Pull
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief pull a specific data from the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename DataType
    > [[ nodiscard ]] auto pull()
        -> ::std::remove_cvref_t<DataType>&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief pull a specific data from the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        ::xrn::meta::constraint::isPointer DataType
    > requires (
        !::xrn::meta::constraint::sameAs<DataType, char>
    ) [[ nodiscard ]] auto pull()
        -> ::std::span<::std::remove_cvref_t<::std::remove_pointer_t<DataType>>>;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief pull a specific data from the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        ::xrn::meta::constraint::isMemoryStr DataType
    > [[ nodiscard ]] auto pull()
        -> ::std::string;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Size
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Update body to match the header's size
    ///
    ///////////////////////////////////////////////////////////////////////////
    void updateBodySize();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Resize body
    ///
    ///////////////////////////////////////////////////////////////////////////
    void resize(
        ::std::size_t newSize
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getBodyAddr()
        -> void*;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getHeader() const
        -> const Message<T>::Header&;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getHeader()
        -> Message<T>::Header&;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getHeaderAddr()
        -> void*;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getBody() const
        -> const ::std::vector<::std::byte>&;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getBody()
        -> ::std::vector<::std::byte>&;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getAsString() const
        -> ::std::string;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getHeaderSize() const
        -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getBodySize() const
        -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getType() const
        -> T;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getTypeAsSystemType() const
        -> Message<T>::SystemType;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getTypeAsInt() const
        -> ::std::uint16_t;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers size
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the size a parameter would take to allocate
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getSize(
        auto&& arg
    ) -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the size a parameter would take to allocate
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getSize(
        const char* arg
    ) -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the size that a container would take to allocate
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getSize(
        ::xrn::meta::constraint::isContiguousContainer auto&& arg
    ) -> ::std::size_t;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers push
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the data into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushMemory(
          ::std::size_t index
        , auto&& arg
        , auto&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
          ::std::size_t index
        , auto& arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
          ::std::size_t index
        , auto&& arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
          ::std::size_t index
        , const char* arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief push the memory of the datum into the already allocated message
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
          ::std::size_t index
        , char* arg
    );

    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
          ::std::size_t index
        , ::xrn::meta::constraint::isContiguousContainer auto& arg
    );

    ///////////////////////////////////////////////////////////////////////////
    void pushSingleMemory(
          ::std::size_t index
        , ::xrn::meta::constraint::isContiguousContainer auto&& arg
    );



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Members
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Contains information about the content of the body
    ///
    ////////////////////////////////////////////////////////////
    Message::Header m_header;

    ////////////////////////////////////////////////////////////
    /// \brief Contains row data as bytes
    ///
    /// begining of the allocated space
    ///
    ////////////////////////////////////////////////////////////
    ::std::vector<::std::byte> m_body;

    ////////////////////////////////////////////////////////////
    /// \brief Index inside the vector to pull out data
    ///
    /// current ptr for the user pulls
    ///
    ////////////////////////////////////////////////////////////
    ::std::size_t m_index;

};

} // namespace xrn::network

///////////////////////////////////////////////////////////////////////////
// Implementation Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Message.impl.hpp>
