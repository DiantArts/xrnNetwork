#pragma once

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Detail/Constraint.hpp>

template <typename T>
consteval T ipow(T num, unsigned int pow)
{
    return (pow >= sizeof(unsigned int)*8) ? 0 : pow == 0 ? 1 : num * ipow(num, pow-1);
}


namespace xrn::network {

///////////////////////////////////////////////////////////////////////////
/// \brief Allows to dynamically store polymorphic data so it can be sent
/// \ingroup network
///
/// \include Message.hpp <xrn/Network/Message.hpp>
///
/// ::xrn::network::Message's purpuse is simplify data sharing by providing
/// a simple way to regroup and act onto multiple polymorphic data into a
/// single object. This message works like a queue (FIFO)
///
/// Usage example:
/// \code
/// enum MessageType { start, stop, last };
/// ::xrn::network::Message<MessageType> m{ MessageType::start, "hello", "you"s, "are"sv };
/// ::std::vector<short> vec{ 5, 3 };
/// m.push(::std::move(vec));
/// auto str1{ m.pull<char*>() };
/// auto str2{ m.pull<char*>() };
/// auto str3{ m.pull<char*>() };
/// auto v1{ m.pull<short*>() };
/// ::fmt::print("{} {} {} {} {} {}\n", str1, str2, str3, v1.size(), v1[0], v1[1]); // output: hello you are 2 5 3
/// \endcode
///
///
///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> class Message {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // static elements
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type describing the message
    ///
    /// The value can be either a UserEnum or a Message::SystemType value.
    ///
    ///////////////////////////////////////////////////////////////////////////
    using EnumUnderType = ::std::uint16_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type describing a size send over
    ///
    ///////////////////////////////////////////////////////////////////////////
    using SizeType = ::std::uint16_t;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default enum for operations outside of the user usage
    ///
    /// Constructs a ::xrn::network::Message containing a point in time with no
    /// value.
    ///
    ///////////////////////////////////////////////////////////////////////////
    enum class SystemType : ::std::uint16_t {
        builtinError = static_cast<::std::uint16_t>(UserEnum::last) + 1
        , builtinUndefined
        , builtinConnectionRequest
        , builtinUdpInformation
        , builtinIdInformation
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Maximum size of the message
    ///
    ///////////////////////////////////////////////////////////////////////////
    static inline constexpr ::std::uint16_t maxSize{
        static_cast<::std::uint16_t>(::ipow(2, 10))
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Describes the contect of the message
    ///
    /// contains a value of one of both enums and a size.
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Header {

        ///////////////////////////////////////////////////////////////////////////
        /// \brief ID that increases with each packet sent
        ///
        ///////////////////////////////////////////////////////////////////////////
        ::std::uint16_t sequence{ 0 };

        ///////////////////////////////////////////////////////////////////////////
        /// \brief The most recent packet sequence number received
        ///
        ///////////////////////////////////////////////////////////////////////////
        ::std::uint16_t ack{ 0 };

        ///////////////////////////////////////////////////////////////////////////
        /// \brief Bitfield encoding the set of acked packets.
        ///
        ///////////////////////////////////////////////////////////////////////////
        ::std::uint32_t ackBits{ 0 };

        ///////////////////////////////////////////////////////////////////////////
        /// \brief Size of the body
        ///
        ///////////////////////////////////////////////////////////////////////////
        ::std::uint16_t bodySize{ 0 };

        ///////////////////////////////////////////////////////////////////////////
        /// \brief Type of the content of the message
        ///
        ///////////////////////////////////////////////////////////////////////////
        ::std::uint16_t messageType{ 0 };

    };




public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Empty message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message() noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a system message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        Message::SystemType messageType
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor for a user message
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Message(
        UserEnum messageType
    ) noexcept;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Message();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Message(
        const Message& other
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Message& other
    ) noexcept
        -> Message&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Message(
        Message&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Message&& that
    ) noexcept
        -> Message&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Body execution
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push the memory into the body
    ///
    /// \throws std::runtime_error If trying to push memory beyond maxSize
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename T
    > void push(
        T& data
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push the memory into the body
    ///
    /// \throws std::runtime_error If trying to push memory beyond maxSize
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename T
    > void push(
        T&& data
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push the memory into the body
    ///
    /// \throws std::runtime_error If trying to push memory beyond maxSize
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushCopy(
        auto* ptr
        , ::std::size_t size
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push the memory into the body
    ///
    /// \throws std::runtime_error If trying to push memory beyond maxSize
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushCopy(
        auto* ptr
        , Message::SizeType size
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move the memory into the body
    ///
    /// \throws std::runtime_error If trying to push memory beyond maxSize
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushMove(
        auto* ptr
        , ::std::size_t size
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move the memory into the body
    ///
    /// \throws std::runtime_error If trying to push memory beyond maxSize
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pushMove(
        auto* ptr
        , Message::SizeType size
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Pull the memory from the body
    ///
    /// \throws std::runtime_error If trying to pull memory beyond bodySize
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename T
    > auto pull()
        -> T&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Pull the memory from the body
    ///
    /// \throws std::runtime_error If trying to pull memory beyond bodySize
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename T
    > auto pull(
        ::std::size_t size
    ) -> T*;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Pull the memory from the body
    ///
    /// \throws std::runtime_error If trying to pull memory beyond bodySize
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename T
    > auto pull(
        Message::SizeType size
    ) -> T*;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Reset the reading pointer
    ///
    ///////////////////////////////////////////////////////////////////////////
    void resetPullPosition();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Accessors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getHeader() const
        -> const Message<UserEnum>::Header&;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getAddr()
        -> ::std::byte*;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief size of the all packet (header + body)
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getSize() const
        -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getBodySize() const
        -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static constexpr auto getHeaderSize()
        -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getAsString() const
        -> ::std::string;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getType() const
        -> UserEnum;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getTypeAsSystemType() const
        -> Message<UserEnum>::SystemType;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getTypeAsInt() const
        -> ::std::uint16_t;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Members
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Contains row data as bytes
    ///
    ////////////////////////////////////////////////////////////
    ::std::array<::std::byte, Message::maxSize> m_message;

    ////////////////////////////////////////////////////////////
    /// \brief Contains information about the content of the body
    ///
    /// header is contained at the begining of the packet
    ///
    ////////////////////////////////////////////////////////////
    Message::Header& m_header{ *new (m_message.data()) Message::Header };

    ////////////////////////////////////////////////////////////
    /// \brief Index inside the vector to pull out data
    ///
    /// current ptr for the user pulls
    ///
    ////////////////////////////////////////////////////////////
    ::std::size_t m_pullPointer{ Message::getHeaderSize() };

};

} // namespace xrn::network

///////////////////////////////////////////////////////////////////////////
// Implementation Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/Message.impl.hpp>
