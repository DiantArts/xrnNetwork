#pragma once

#include <xrn/Network/IClient.hpp>

namespace xrn::network {

///////////////////////////////////////////////////////////////////////////
/// \brief Interface detailing basic clients' features
/// \ingroup network
///
/// \include AClient.hpp <xrn/Network/Client/AClient.hpp>
///
/// ::xrn::network::AClient's purpuse is simplify data share by providing a
/// simple way to regroup and act onto multiple data into a single object.
/// The client is designed as Event programming and the user must implement
/// the on... methods to interact with it
///
/// \see ::xrn::network::IClient, ::xrn::network::Message
///
///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::hasValueLast UserEnum
> class AClient
    : public ::xrn::network::IClient<UserEnum>
{

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit AClient();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    /// Clears the registry opon destruction.
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual ~AClient();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    AClient(
        const AClient& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const AClient& other
    ) noexcept
        -> AClient& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    AClient(
        AClient&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        AClient&& that
    ) noexcept
        -> AClient&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Thread
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Join the thread containing asio context
    ///
    ///////////////////////////////////////////////////////////////////////////
    void joinThread();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Incomming messages
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Pull a single incomming message
    ///
    /// Calls handleIncommingSystemMessage() method to clear out system
    /// messages, then call onReceive() is the message was not handled
    ///
    /// \handleIncommingSystemMessage(), onReceive()
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pullIncommingMessage();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Pull all incomming messages
    ///
    /// \see pullIncommingMessage
    ///
    ///////////////////////////////////////////////////////////////////////////
    void pullIncommingMessages();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Wait for messages to arrive, then call pullIncommingMessages()
    ///
    /// \see pullIncommingMessage
    ///
    ///////////////////////////////////////////////////////////////////////////
    void blockingPullIncommingMessages();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Handle if the message is a system message
    ///
    /// \param message Message to handle
    /// \param connection Connection that sent the message
    ///
    /// \return True if the message was handled, false otherwise
    ///
    /// \see ::xrn::network::Message, ::xrn::network::Connection
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual auto handleIncommingSystemMessages(
        ::xrn::network::Message<UserEnum>& message
        , ::std::shared_ptr<::xrn::network::Connection<UserEnum>> connection
    ) -> bool = 0;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Notify the inccomming message queue that an event occured
    ///
    /// The event is most likely that a new message arrived (can be that
    /// the client disconnects and more).
    ///
    ///////////////////////////////////////////////////////////////////////////
    void notifyIncommingMessageQueue();




private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Members
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Asio context running on m_threadContext
    ///
    ////////////////////////////////////////////////////////////
    ::asio::io_context m_asioContext;

    ////////////////////////////////////////////////////////////
    /// \brief Thread containing the asio context
    ///
    ////////////////////////////////////////////////////////////
    ::std::thread m_threadContext;



    ////////////////////////////////////////////////////////////
    /// \brief Queue of all the messages received
    ///
    ////////////////////////////////////////////////////////////
    ::xrn::network::detail::Queue<::xrn::network::OwnedMessage<UserEnum>>& m_messagesIn;

};

} // namespace xrn::network

///////////////////////////////////////////////////////////////////////////
// Implementation Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Network/AClient.impl.hpp>
