#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/// \brief Constructor
///
///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> ::xrn::network::client::Client<UserEnum>::Client(
    const ::std::string& host
    , ::std::uint16_t port
)
{
    this->connect(host, port);
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rule of 5
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> ::xrn::network::client::Client<UserEnum>::~Client()
{
    this->disconnect();
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> ::xrn::network::client::Client<UserEnum>::Client(
    Client&& that
) noexcept = default;

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> auto ::xrn::network::client::Client<UserEnum>::operator=(
    Client&& that
) noexcept
    -> Client& = default;



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Connection
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> void ::xrn::network::client::Client<UserEnum>::connect(
    const ::std::string& host
    , ::std::uint16_t port
)
{
    m_connection = ::std::make_shared<::xrn::network::Connection<UserEnum>>(
        host, port, *this
    );
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> void ::xrn::network::client::Client<UserEnum>::disconnect()
{
    m_connection.reset();
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> auto ::xrn::network::client::Client<UserEnum>::isConnected() const
    -> bool
{
    return m_connection && m_connection->isConnected();
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> auto ::xrn::network::client::Client<UserEnum>::isRunning() const
    -> bool
{
    this->isConnected();
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Incomming messages
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> void ::xrn::network::client::Client<UserEnum>::send(
    typename ::xrn::network::Message<UserEnum>::SystemType messageType,
    auto&&... args
)
{
    m_connection->send(
        ::xrn::network::Message<UserEnum>{ messageType, ::std::forward<decltype(args)>(args)... }
    );
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> void ::xrn::network::client::Client<UserEnum>::send(
    UserEnum messageType,
    auto&&... args
)
{
    m_connection->send(
        ::xrn::network::Message<UserEnum>{ messageType, ::std::forward<decltype(args)>(args)... }
    );
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> void ::xrn::network::client::Client<UserEnum>::send(
    const ::xrn::network::Message<UserEnum>& message
)
{
    m_connection->send(message);
}

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> void ::xrn::network::client::Client<UserEnum>::send(
    ::xrn::network::Message<UserEnum>&& message
)
{
    m_connection->send(::std::forward<decltype(message)>(message));
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Incomming messages
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    ::xrn::network::detail::constraint::isValidEnum UserEnum
> auto ::xrn::network::client::Client<UserEnum>::handleIncommingSystemMessages(
    ::std::shared_ptr<::xrn::network::Connection<UserEnum>> connection
    , ::xrn::network::Message<UserEnum>& message
) -> bool
{
    return false;
}
